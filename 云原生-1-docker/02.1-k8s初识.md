## 一 k8s简介

Kubernetes（K8s，8即k与s之间有8个字母）是Google在2014年发布的一个开源项目。  


## 二 K8s架构

#### 2.1 Cluster（集群）

Cluster是计算、存储和网络资源的集合，Kubernetes利用这些资源运行各种基于容器的应用。

#### 2.2 Master（控制主节点）

Master是Cluster的大脑，它的主要职责是调度，即决定将应用放在哪里运行。Master运行Linux操作系统，可以是物理机或者虚拟机。为了实现高可用，可以运行多个Master。调度应用程序、维护应用程序的所需状态、扩展应用程序和滚动更新都是master的主要工作。

#### 2.3 Node（节点）

Node的职责是运行容器应用。Node由Master管理，Node负责监控并汇报容器的状态，同时根据Master的要求管理容器的生命周期。  

Node是 Kubernetes 集群中的工作机器，可以是物理机或虚拟机。每个工作节点都有一个 kubelet，它是管理节点并与 Kubernetes Master 节点进行通信的代理。节点上还应具有处理容器操作的容器运行时，例如 Docker。一个 Kubernetes 工作集群至少有三个节点。 Master 管理集群，而 Node（节点）用于托管正在运行的应用程序。  

当你在 Kubernetes 上部署应用程序时，你可以告诉 master 启动应用程序容器。Master 调度容器在集群的节点上运行。节点使用 Master 公开的 Kubernetes API 与 Master 通信。用户也可以直接使用 Kubernetes 的 API 与集群交互。  

#### 2.4 Pod（资源对象）

Pod（资源对象）是Kubernetes的最小工作单元。每个Pod包含一个或多个容器。Pod中的容器会作为一个整体被Master调度到一个Node上运行。  

Kubernetes引入Pod主要基于下面两个目的： （1）可管理性。 有些容器天生就是需要紧密联系，一起工作。Pod提供了比容器更高层次的抽象，将它们封装到一个部署单元中。Kubernetes以Pod为最小单位进行调度、扩展、共享资源、管理生命周期。 （2）通信和资源共享。 Pod中的所有容器使用同一个网络namespace，即相同的IP地址和Port空间。它们可以直接用localhost通信。同样的，这些容器可以共享存储，当Kubernetes挂载volume到Pod，本质上是将volume挂载到 Pod中的每一个容器。     

Pods有两种使用方式：
- 运行单一容器：one-container-per-Pod是Kubernetes最常见的模型，这种情况下，只是将单个容器简单封装成Pod。即便是只有
一个容器，Kubernetes管理的也是Pod而不是直接管理容器
- 运行多个容器：哪些容器应该放到一个Pod中？ 答案是：这些容器联系必须非常紧密，而且需要直接共享资源

#### 2.5  Controller（控制器）

Kubernetes通常不会直接创建Pod，而是通过Controller来管理Pod的。Controller中定义了Pod的部署特性，比如
有几个副本、在什么样的Node上运行等。为了满足不同的业务场景，Kubernetes提供了多种Controller，包括
Deployment、ReplicaSet、DaemonSet、StatefuleSet、Job等：
- （1）Deployment是最常用的Controller，比如在线教程中就是通过创建Deployment来部署应用的。Deployment可以管理Pod的多个副本，并确保Pod按照期望的状态运行。
- （2）ReplicaSet实现了Pod的多副本管理。使用Deployment时会自动创建ReplicaSet，也就是说Deployment是通过ReplicaSet来管理Pod的多个副本的，我们通常不需要直接使用ReplicaSet。 
- （3）DaemonSet用于每个Node最多只运行一个Pod副本的场景。正如其名称所揭示的，DaemonSet通常用于运行daemon。 （4）StatefuleSet能够保证Pod的每个副本在整个生命周期中名称是不变的，而其他Controller不提供这个功能。当某个Pod发生故障需要删除并重新启动时，Pod的名称会发生变化，同时StatefuleSet会保证副本按照固定的顺序启动、更新或者删除。
- （5）Job用于运行结束就删除的应用，而其他Controller中的Pod通常是长期持续运行。

#### 2.6 Service（服务）

Deployment可以部署多个副本，每个Pod都有自己的IP，外界要通过 Service 访问这些副本。 （Pod很可能会被频繁地销毁和重启，它们的IP会发生变化，用IP来访问不太现实）。  

Kubernetes Service定义了外界访问一组特定Pod的方式。Service有自己的IP和端口，Service为Pod提供了负载均衡。  

Kubernetes运行容器（Pod）与访问容器（Pod）这两项任务分别由Controller和Service执行。

#### 2.7 NameSpace（命名空间）

Namespace 是对一组资源和对象的抽象集合，比如可以用来将系统内部的对象划分为不同的项目组或用户组。  
 
如果有多个用户或项目组使用同一个Kubernetes Cluster，如何将他们创建的Controller、Pod等资源分开呢？ 答案就是Namespace。  

Namespace可以将一个物理的Cluster逻辑上划分成多个虚拟Cluster，每个Cluster就是一个Namespace。不同Namespace里的资源是完全隔离的。  

Kubernetes默认创建了两个Namespace：
- default：创建资源时如果不指定，将被放到这个Namespace中
- kube-system：Kubernetes自己创建的系统资源将放到这个Namespace中

## 三 k8安装

#### 3.0 安装前提

K8s有三种搭建方式：
- 单机 minikube：https://github.com/kubernetes/minikube
- 集群 kubeadm：https://github.com/kubernetes/kubeadm
- 二进制：https://www.qikqiak.com/post/manual-install-high-available-kubernetes-cluster/

三台服务器环境准备：
- k8s-master001 192.168.110.116 
- k8s-node001 192.168.110.117 
- k8s-node002 192.168.110.118

三台机器环境：
```
# 安装基本工具
sudo -i
apt-get install apt-transport-https ca-certificates curl software-properties-common lrzsz -y

# 禁用SWAP
swapoff -a
sed -i '/ swap / s/^/#/' /etc/fstab

# 更新
apt-get update
apt-get upgrade

# 防火墙管理
#1804查看防火墙状态
$ sudo ufw status
#关闭防火墙
$ sudo ufw disable
#开启防火墙
$ sudo ufw enable

# 主机名查看与设置
#查看主机名
$hostname
#设置主机名 (修改主机名需要两个文件)
$ sudo vim /etc/hostname
$ sudo vim /etc/hosts
#重启
$ reboot
```

#### 3.1 安装docker

```
#docker相关软件
$ sudo apt-get install apt-transport-https ca-certificates curl software-propertiescommon lrzsz -y
#离线安装docker
$ tar xzvf docker_v18.03.1_ce.tar.gz
$ cd docker_v18.03.1_ce && ./install.sh
#配置加速器
$ curl -sSL https://get.daocloud.io/daotools/set_mirror.sh | sh -s
http://f1361db2.m.daocloud.io
#由于全程使用root账户所以就不需要进行docker权限的设置了
```

#### 3.2 master主机操作

搭建镜像仓库：
```
#获取仓库镜像
$ docker pull registry
#启动仓库容器
$ docker run --restart=always --name=registry -d -p 5000:5000 registry
```

进行仓库配置：
```
#编辑docker配置文件
sudo vim /etc/default/docker
#最末尾添加 当前仓库主机ip
DOCKER_OPTS="--insecure-registry 192.168.110.116:5000"
#创建服务依赖文件
:~$ sudo mkdir -p /etc/systemd/system/docker.service.d
:~$ sudo vim /etc/systemd/system/docker.service.d/Using_Environment_File.conf
#内容如下：
[Service]
EnvironmentFile=-/etc/default/docker
ExecStart=
ExecStart=/usr/bin/dockerd -H fd:// $DOCKER_OPTS
#重载服务配置文件
:~$ systemctl daemon-reload
#重启docker
:~$ systemctl restart docker
```

安装Kubeadm等程序：
```
#依赖
apt-get install ethtool ebtables -y
#将002.001.k8s.deb.v1.11.1.tar.gz解压
$ tar xzvf 002.002.k8s.node.v1.11.1.tar.gz

#进入文件夹
$ cd k8s.deb.v1.11.1
#启动安装脚本
$ ./install.sh
#脚本内容
dpkg -i apt-transport-https_1.6.3_all.deb
#k8s网络接口插件
dpkg -i kubernetes-cni_0.6.0-00_amd64.deb
dpkg -i cri-tools_1.11.0-00_amd64.deb
dpkg -i socat_1.7.3.2-2ubuntu2_amd64.deb
#kubelet：负责 Pod 的创建、启动、监控、重启、销毁等工作，同时与 Master 节点协作，实现集群管理的
基本功能。
dpkg -i kubelet_1.11.1-00_amd64.deb
#命令行工具
dpkg -i kubectl_1.11.1-00_amd64.deb
#kubeadm官方给出的安装方法
dpkg -i kubeadm_1.11.1-00_amd64.deb
```

导入k8s安装所需镜像：
```
#解压压缩包
$ tar xzvf 002.002.k8s.master.v1.11.1.tar.gz
#进入文件进行安装
$ cd k8s.master.v1.11.1
#运行脚本进行镜像的导入
$ ./loadall.sh
```


安装k8s：
```
#解压压缩包
$tar xzvf 003.kubeadm_init.tar.gz
#进入文件
cd kubeadm_init
#进行初始化安装
$ ./kubeadm_init.sh #注意修改脚本中初始化的网络地址
```

执行后内容：
```
Your Kubernetes master has initialized successfully!
To start using your cluster, you need to run the following as a regular user:
mkdir -p $HOME/.kube
sudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config
sudo chown $(id -u):$(id -g) $HOME/.kube/config

You should now deploy a pod network to the cluster.
Run "kubectl apply -f [podnetwork].yaml" with one of the options listed at:
https://kubernetes.io/docs/concepts/cluster-administration/addons/
You can now join any number of machines by running the following on each node
as root:
#其他的都不是太重要主要是这一句是用来让其他node节点加入集群的操作所以要保存
kubeadm join 192.168.110.158:6443 --token ttw6dz.d2v8nqtyx5kipxlu --discoverytoken-ca-cert-hash
sha256:df233ca36396ba0ecc2b727ca8b4dd6074091c27f7644ae054d671d5b0d27b79
```

如果失败：
```
#如果创建失败或者是集群加入失败可以使用如下命令重新开始
kubeadm reset重新设置
```

#### 3.3 Node节点操作

设置加速器文件：
```
#执行加速器命令
$ curl -sSL https://get.daocloud.io/daotools/set_mirror.sh | sh -s
http://f1361db2.m.daocloud.io
#修改加速器文件
sudo vim /etc/docker/daemon.json
#内容如下 的ip为默认使用的仓库
{"registry-mirrors": ["http://f1361db2.m.daocloud.io"],"insecure-registries": [
"192.168.110.116:5000"]}
```

安装Kubeadm等程序
```
#依赖
apt-get install ethtool ebtables -y
#将002.001.k8s.deb.v1.11.1.tar.gz解压
$ tar xzvf 002.002.k8s.node.v1.11.1.tar.gz
#进入文件夹
$ cd k8s.deb.v1.11.1
#启动安装脚本
$ ./install.sh
```

安装node节点相关程序:
```
#解压
tar xzvf 004.kubernetes-dashboard.tar.gz
#进入
cd kubernetes-dashboard
#执行脚本
./install.sh
```

使用命令加入集群:
```
#这个命令是在创建master的时候或得到的
$ kubeadm join 192.168.110.116:6443 --token clgahe.stw4d93ihds0k5d4 --discoverytoken-ca-cert-hash
sha256:2ccc882ca893f79749fe7ba8e81a9ed87772cfff4dda6f88db68b6858e00081b
#如果不成功请重新来过
```

在Master上安装Dashboard:
```
#解压
$ tar xzvf 004.kubernetes-dashboard.tar.gz
#进入
$ cd kubernetes-dashboard
#执行
$ ./install.sh
```
