## 一 消息的可靠性

生产端的保证：
- 保证消息的成功发出
- 保证MQ节点能够成功接收消息
- 发送端收到MQ节点的确认应答
- 完善的消息补偿机制

## 二 生产端延迟投递

### 2.1 方案一：消息落库

在发送消息前先持久化，然后对消息状态进行状态标记。对出现异常的消息（持久化了，但是未发送）进行重新发送尝试

![](../images/mq/mq-11.png)  

贴士：其实很多分布式的方案如二次提交、柔性提交并未在分布式系统中占据主要位置，大多采取的方案仍然是补偿方案。  

在图示中的step3，如果Broker收到消息在返回confirm时发生断网，就会出现生产者一直无法收到确认消息的问题，此处需要设计一个超时机制，发生超时的消息应该在生产端进入分布式定时任务轮询队列中（即重新out地Retry Send）。   

该方案缺陷：在高并发场景下性能很低
- 消息进行两次持久化I/O
- 消息的状态需要额外记录

### 2.2 方案一：延迟投递

对消息进行二次确认、回调检查，该方式适合互联网厂商的高并发场景，虽然也不能保证消息的100%投递成功，但是其减少了持久化操作！  

![](../images/mq/mq-11.png)  

Upstream即消息生产者，会先将订单入库（此时是直接一次性入库）。在Step1其实一次性生成了2条消息：
- first Send：真实的消息投递
- Second Send Delay Check：延迟多少分钟后发送该消息，用于确认

消费端在Step3需要监听消费队列，一旦发现消息处理完毕，会在Step4发送新的confirm消息，投递到MQ。  

在Step5，是一个全新的回调服务，会一直监听是否有confirm消息到来，如果有新消息到来，则会进行消息的持久化存储。该服务该会监听在Step2中延迟发送的一个check消息，并对其进行处理。  

callback服务就类似于一个补偿服务！  

## 三 消费端幂等性

### 3.1 幂等性概念

> 幂等性：对一个事情重复操作N次（100次，1000次等等），其结果是一致的
> 在消息队列中，幂等性的机制是为了避免 消息的重复消费问题。消费端实现幂等性，意味着即使受到了多条一样的消息，也不会被消费多次

使用数据库的乐观锁来解释，使用版本号来控制库存超卖：
```
update store set count = count - 1,version = version + 1 where version = currentVersion
```

在下单时，先查询到version的版本号，假设为currentVersion，
由于在更新时存在 `where version = currentVersion`的条件限制，就不会出现超卖现象。   

### 3.2 幂等性主流实现机制

常见的业界主流幂等性操作：
- 唯一ID + 指纹码 机制，利用数据库主键去重
  - 实现方式：`select count(1) from order where id = 唯一ID+指纹码`，返回非0就证明已经被操作了，无需insert
  - 实现简单，但高并发下有数据库写入性能瓶颈
  - 解决方案：跟进ID进行分库分表进行算法路由，实现分压、分流
- 利用Redis的原子性实现
  - 原理：set操作会将存在的数据进行更新，这样可以简单实现一个原子特性
  - 需要考虑的问题：如果需要落库，那么如何做到数据库和缓存的原子性。如果不进行落库，则需要定时同步策略

## 四 生产端 消息确认confirm机制

confirm机制：
> 消息确认：生产者投递消息后，如果Broker收到消息，则会给生产者一个应答。生产者接收应答后，用来确定该消息是否正常。

RabbitMQ确认消息步骤：
- 1 在channel上开启确认模式：`channel.confirmSelect()`
- 2 在channel上添加监听：`addConfirmListener`，监听成功和失败的返回结果。

## 五 生产端 Return消息机制

Return Listenr用于处理一些不可路由的消息。  

Mandatory设置为true后，则监听器会接收到路由不可达消息，如果未false，则Broker会自动删除不可达消息！  

## 六 消费端的消息监听

一般消息的监听放在一个循环中，进行consumer.nextDelivery方法进行获取吓一跳消息，然后进行消费处理。该代码并不优雅！  

消费端可以实现自定义监听。

## 七 消费端限流

如果有以下场景：RabbitMQ服务器上堆积上了上万条消息，此时打开一个消费端，会有大量消息瞬间推送过来，客户端会无法同时处理这么多数据。  

针对该情况，RabbitMQ提供了qos（服务质量保证）功能，在非自动确认消息的前提下，如果有一定的消息堆积，不进行新消息的消费。所以在生产环境中，**必须设定AutoACK为false**！！！设置后，消息被确认前是不会到达消费端的。  

`channel.BasicQos()`方法可以设定限流的一些参数。

## 八 消费端ACK与重回队列

消费端重回队列：针对没有处理成功的消息，消息会重新递送给Broker。  

在生产环境中，一般会关闭重回队列（设置为false）。 

## 九 消息TTL

TTL即Time To Live 生存时间：
- RabbitMQ支持消息的过期时间：在发送消息时指定过期时间
- RabbitMQ支持队列的过期时间：从入队开始计算，超过了队列超时时间，则自动清除消息

## 十 死信队列

死信队列：DLX，Dead-Letter-Exchange。RabbitMQ的死信队列与其他MQ不同，是与交换机相关的。  

当消息在一个队列中变成死信（dead message）之后，能被重新publish到另一个Exchange，这个Exchange就是DLX。  

消息变成死信的情况：
- 消息被拒绝：`basic.reject/basic.nack`，并且requeue=false（不重回队列）
- 消息TTL过期
- 队列已满

DLX和普通的交换机没有区别，主要用于让RabbitMQ将死信路由到另外一个队列中。   


设置死信队列：
- Exchange：dlx.exchange
- Queue：dlx.queue
- RoutingKey：#
- 在队列中添加一个扩展参数：arguments.put("x-dead-letter-exchange", "dlx.exchange")