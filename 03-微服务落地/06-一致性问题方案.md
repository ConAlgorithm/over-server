## 一 事件溯源

事件溯源（Event-Sourcing）一般用于领域对象模型中。在一个对象从创建到销毁的整个生命周期中，会产生大量的事件（Event），然而每种事件都有自己所属的事件类型（Event Type）。事件类型是可以枚举的，而事件无法枚举，事件包含时间、事件类型、模型等信息。如 “创建”是一种事件类型，而“在某时刻创建一个产品”则是一个事件。  

事件记录：一般情况下，我们只会讲对象的最终状态记录到数据库中，而不会去记录每个对象的历史事件变更。事件溯源要求在记录对象状态同时，还要记录对象所发生的一系列事件，这些事件需要随时间的先后顺序依次记录到数据库中。  

每个模型拥有自己的唯一ID：ModelID，事件也同样拥有唯一的ID：EventID。可以通过EventID在事件表中查询对应的模型ID，这个过程称为事件溯源。  

事件溯源需要与MQ相结合才能发挥价值，从而实现分布式事务控制，具体步骤：
- 1 将事件写入消息队列。假设有个服务FooService中，现在需要插入一条Foo对象到FooTable，在执行该操作时，也需要：
  - 创建一个事件Event对象
  - 将名为"CREATEFOO"的Event事件插入到事件表Event Table，这2个数据库操作要确保在同一个事务中提交
  - 将事件对象写入成功队列“foo-success-queue”
- 2 从消息队列中获取事件，并操作模型表，若有异常情况，则将源事件再次写入消息队列。假设服务BarService消费FooService
  - 从Success Queue中获取Event对象
  - 完成自己的具体业务逻辑（即插入Bar对象到BarTable）。
  - 如果出现异常写入失败队列将Success Queue中获取的Event对象写入失败队列Failure Queue
- 3 开始事件溯源：从消息队列获取事件，操作事件表与模型表，FooService不再是消息的生产者，而称为消费者
  - 从失败队列取回曾经发送到成功队列的Event对象
  - 根据EventID查询到FooID
  - 根据FooID删除记录：删除曾经插入的Foo对象


在上述方案中，没有过分追求数据的强一致性，利用事件溯源与MQ就能确保数据的最终一致性，从而控制了分布式事务。在实际生产环境中，推荐合理的服务切分来最大限度的避免分布式事务。  


