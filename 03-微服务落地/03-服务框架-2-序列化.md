## 一 序列化与反序列化概述

- 序列化：把对象转换成字节序列的过程
- 反序列化：把字节序列回复为对象的过程

开发时，使用面向对象能够有效的使项目工程化，但是对象不能直接作为数据进行存储、网络传输，此时需要将对象转化为连续空间的二进制字节流。  

主要使用场景：
- 数据网络传输：Socket发送的数据不能是对象，必须是连续空间的二进制字节流。进行远程跨进程服务调用时（如RPC），需要使用特定的序列化技术对需要进行网络传输的对象进行编码、解码
- 缓存的KV存储：Redis/Memcache的value必须是连续空间的二进制字节流
- 数据库索引的磁盘存储：索引在内存中是B+树或者Hash格式，该格式不能直接存储在磁盘上，需要先进行序列化

序列和反序列化功能现在是大多分布式服务框架的一个组成部分，在集成该功能时，考虑的因素有：
- 性能：序列化后码流大小、序列化/反序列化的速度、序列化/反序列化系统的开销（CPU或堆内存）
- 扩展性：支持数据向前兼容，如新增字段、删除字段、调整字段顺序
- 跨语言支持：支持更多的编程语言实现  

贴士：Google开发的ProtoBuf序列化格式在各方面都拥有绝对优势。

常见的需要序列化的对象、文件：
- xml：xml使用标签表示数据，可读性高，且具备语言无关性。但是xml序列化后码流很大，只适合并发较低的企业级项目开发
- json：json是一种轻量级的数据交换格式，支持大多数据类型，其码流很小，可读性也高，是目前较为流行的数据传输格式。常用的序列化工具为阿里的Fastjson、Google的GSON
- 对象内部序列化：大多编程语言内部支持将该语言的对象进行序列化，如Java的Serializer接口，默认实现即可将对象序列化，但是这种方式往往跨语言性不足，且很多语言内部实现都有性能不足问题，尤其Serializer接口的实现，码流很大，且在序列化深层引用对象时容易引起OOM异常
- proto：ProtoBuf使用的序列化格式，码流小，性能极高，跨语言。

## 二 ProtoBuf的使用

