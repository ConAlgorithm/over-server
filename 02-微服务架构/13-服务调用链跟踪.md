## 一 调用链跟踪解释

典型的分布式服务调用关系如图：  
![](../images/micro/03.png)  

从图中可知，一个用户的请求到达内部服务后，其调用结构是一个树型结构，树节点是整个架构的基本单元，每个节点是一个独立的服务节点。  

谷歌在2010年发布的论文Dapper中介绍了谷歌分布式系统跟踪的基础原理和架构。在该论文中，每个节点都对应一个Span，节点之间的连线表示Span和它的父Span之间的关系，具体表现为依次调用请求和响应的调用关系。我们可以把描述依次请求调用和响应组成的数据叫做调用信息。  

现在我们重点关注两个服务之间的通信，如选图所示：  
![](../images/micro/04.png)

两个服务之间有成千上万次通信，服务 1 与服务 2 进行交互时，会发送一个请求 1 ，并接收到一个响应 1 ，那么我们通过什么手段标识响应和请求是一对呢？  

服务 2 也会接收到一个请求 1 ，并发送一个响应 1 ，我们又如何将这一对请求和响应与服务1 的请求和响应联系在一起呢？如果选择在TCP层上跟踪，显然是极其复杂的，
谷歌的 Dapper 论文通过增加应用层的标记来对服务化中的请求和响应建立联系，例如：它通过 HTTP 协议头携带标记信息，标记信息包括标识调用链的唯一流水 ID，这里叫作 Trace!D，以及标识调用层次和顺序的 SpanID 和 ParentSpanID 。  

如图所示：  
![](../images/micro/05.png)  

一次远程调用的过程可以分为 4 个阶段， 每个阶段对应一种远程调用信息的类型：
- 调用端发送请求的调用信息。
- 被调用端接收请求的调用信息。
- 被调用端发送响应的调用信息。
  - 成功响应
  - 异常响应
- 调用端接收响应的调用信息。

上面每种类型的远程调用信息包含：
- 调用端或者被调用端的IP、系统ID
- 本次请求的TraceID、SpanID、ParentSpanlD
- 时间戳、调用的方法名称及远程调用信息的类型等 

我们为远程调用信息的类型定义的枚举类型如下：
- RPCPhase.P 1 ：调用端发送请求的调用信息类型 。
- RPCPhase.P2 ：被调用端接收请求的调用信息类型 。
- RPCPhase.P3 ：被调用端发送响应成功的调用信息类型。
- RPCPhase.P4：调用端接收响应成功的调用信息类型。
- RPCPhase.E3 ：被调用端发送响应失败的调用信息类型。
- RPCPhase.E4：调用端接收响应失败的调用信息类型。
- RPCPhase.SIB：主子线程间传递调用信息类型。

在保持系统最终一致性的定期校对模式中，需要同时事后异步的进行批量校对，基于全局的唯一流水ID将一个请求在分布式系统中的流转路径进行聚合，然后过程中传递和保存的SpanID将聚合的请求路径通过树形结构进行展示，这样可以让系统维护者快速发现问题、定位问题的服务节点。  

## 二 TraceID 

我们在前端接收用户的请求后，会为用户的请求分配一个 TraceID，此例中TraceID 为 0001 ，然后在内部服务调用时，会通过应用层的协议将 TraceID 传递到下层服务，直到整个调用链的每个节点都拥有了 TraceID，这样，在系统出现问题时，我们可以使用这个唯一的 TraceID 迅速找到系统间发生过的所有交互请求和响应，并定位问题发生的节点。  

如图所示：  
![](../images/micro/06.png)   

Vesta ( http://vesta.cloudate.net/ ）是一款原创的多场景的互联网发号器，此发号器可以作为全局唯一的流水号，也就是 TraceID 。  

## 三 SpanID

TraceID 解决了系统间调用关系的串联问题，对调用关系串联后，我们能够找到服务于一个用户请求的调用和响应消息的集合，这些集合里面的请求和响应都是为了同一次用户请求而服务的，但是我们无法标识和恢复这些请求和响应调用时的顺序和层级关系，例如，我们无法得知 RPC 调用 2 发生在 RPC 调用 3 之前，也无法得知前端服务调用了两个从前端服务看来是下层服务的后端服务 l 和后端服务 2，也就是说无法恢复调用的层级结构或者树形结构。  

因此，我们需要附加的信息在系统之间的请求和响应消息中传递，它就是 SpanID ， 这里SpanID 包含 SpanID 和 ParentSpanID ，后续在没有明确说明的情况下， SpanID 也包含ParentSpanID。

如图所示：  
![](../images/micro/07.png)   

SpanlD 和 ParentSpanlD 组合在 一起就可以表示一个树形的调用 关 系， 一 个 Span ID 和ParentSpanID 记录了一次调用的节点信息。 SpanID 表示 当前为一个调用节点， ParentSpanID 表示这个调用节点的父节点，通过这两个数据，我们就可以恢复树形的调用链。 

现在我们从时序的角度来看 SpanID 和 ParentSpanID 在调用链中携带的信息和含义，如图：  
![](../images/micro/08.png)  

当系统出现故障时，我们需要为开发、应急和运维人员显示树形的调用链，只需以下 4 步即可。
- 1 通过 TraceID 把一整条调用链的所有调用信息收集到一个集合中，包括请求和响应。
- 2 通过 SpanID 和 ParentSpanID 恢复树形的调用树，ParentSpanID 为－ 1 的节点为调用树的根节点，也是调用请求的源头请求。
- 3 识别调用链中出错或者超时的节点，并且做出标记。
- 4 把恢复的调用树和出错的节点信息通过某种图形显示到 UI 界面上。

SpanID 是一个 64 位的整型值，有多种策略产生 SpanID 。
- 1 使用随机数产生 SpanID ，理论上随机数是有可能重复 的，但是由于 64 位长整型值的取值范围为［－2<sup>63</sup>, 2<sup>63</sup>-1 ］，重复的可能性微乎其微，井且本地生成随机数的效率会高于其他方法。
- 2 使用分布式的全局唯一的流水号生成方式，可参考互联网发号器 Vesta.
- 3 每个 SpanID 包含所有父亲及前辈节点的 SpanID ，使用圆点符号作为分隔符，不再需要 ParentSpanlD 宇段，如下图所示。这种方案实现起来简单，但是在某些场景下有一个致命的缺点，当一个请求的调用链有太多节点和层次时， SpanID 会携带太多的冗余信息，导致服务间调用的性能下降 。  

![](../images/micro/09.png)  

## 四 业务链

在生产实践中，由于业务流程的复杂性， 一个业务流程的完成由用户的多次请求组成，这些请求之间是有关联的，我们在串联调用链之后，会根据业务的属性，将不同的调用链聚合在一起形成业务链，便于开发、应急和运维人员排查问题 。    

例如用户在电商平台下单后会进行支付，在支付后由于对货物不满意 ，会申请退款。要完成这样的整个业务流程至少需要（远远不止） 3 次用户请求，这 3 次用户请求是通过业务系统的 D 进行关联的，用户下单后会产生订单号，支付时会传入订单号，退款时也会传入原订单号来进行退款校验及获得退款信息。  

我们需要在多次请求之间建立联系，可以通过业务系统的订单号来串联业务链，调用链是一个简单的树形结构，而业务链是一个森林结构：  
![](../images/micro/10.png)  

我们在恢复了下单、支付和退款调用链之后，通过业务的 ID 订单号将三个调用链关联在一起，这样开发、应急和运维人员可以以更高的视角来查看业务系统的运行状态 ， 迅速定位某个用户的请求卡在了哪个链的哪个请求节点上，帮助业务人员和运营人员更好地了解产品的运行情况或者获得一些有价值的业务系统。  

## 五 常用开源服务调用链

业界常用的APM项目（分布式服务调用链跟踪）有：
- Pinpoint：诞生于谷歌论文，基于Java开发的APM工具，用于大规模分布式系统，帮助开发人员分析系统结构、程序组件之间的数据互联
- Zipkin：诞生于谷歌论文，支持Java、Go、Scala等语言，能够收集服务调用的时序数据，解决微服务中定位超时问题。该框架会通过应用程序中挂载字节码增强库来讲实时数据汇报给Zipkin。
- CAT：美团开元的实时应用和性能监控系统
- 商业化产品：如听云、博睿、OneAPM

## 六 调用链的具体实现

### 6.1 整体架构

调用链跟踪系统通常由采集器、处理器和分布式存储系统组成，经过这几个模块处理后的调用数据会在调用链展示系统中对外提供查看和查询等功能，整体的调用链跟踪系统的通用实现架构如图：  

![](../images/micro/11.png)   

每个模块的功能职责如下：
- 采集器：负责把业务系统的远程服务调用信息从业务系统中传递给处理器。
- 处理器：负责从业务系统的采集器中接收服务调用信息并聚合调用链，将其存储在分布式数据存储中，以及对调用链进行分析，井输出给监控和报警系统 。
- 分布式存储系统：存储海量的调用链数据，并支持灵活的查询和搜索功能。
- 调用链展示系统：支持查询调用链、业务链等功能 

### 6.2 TraceID和SpanID在服务间的传递

TraceID和SpanID需要在很多场景中实现传递。如图所示：  

![](../images/micro/12.png)   

- 单个应用（进程内）内部传递：Java中可以使用ThreadLocal传递
- 不同服务间传递：需要利用网络通信协议传递，比如RESTFUL的api中，可以存放于HTTP头中，RPC远程调用中则可以为RPC序列化协议增加定制化字段
- 不同线程间传递：非核心链路逻辑往往会异步处理，这位于异步线程中，可以在创建这样的线程时，将ID一并传递过去，放在子线程的ThreadLocal中
  - 贴士：可以将这个过程封装在独立使用的线程池中，这种做法同样适用于go的协程
- 应用与消息队列间传递：消息队列往往用于解耦与削峰，有三种传递方式
  - 1 修改消息队列底层实现协议，让ID透明传递，这样就不需要应用层有感知，但是修改消息队列代价较大
  - 2 在应用层的报文上增加附属字段，应用层在发送消息时，手工将ID通过报文传递，该方案实现简单、快捷，但是侵入了业务系统
  - 3 在第二种方式基础上，为消息队列客户端库做定制化，每次发送消息时，将ID增加到消息报文中，这种方式既能不侵入系统，避免人为疏忽一些ID的缺失，也能不用更改消息队列底层业务协议
- 缓存和数据库之间传递：也有两种实现方式
  - 1 对缓存和数据库进行二次开发：和应用于消息队列的传递方案一一样，代价极大 
  - 2 封装缓存、数据库的客户端，将ID与访问的数据进行关联，推荐该方案

### 6.3 采集器

采集器用于采集ID（TraceID和SpanID）数据、推送数据，通过采集器从业务系统中把ID传输到调用链的处理器上。  

采集器的实现四种方法：
- 应用层主动推送：实现简单快速，但是调用信息侵入了业务代码，对重构压力较大
- AOP推送：Java中的方案,在业务层中使用AOP拦截目标服务调用,将请求/响应信息收集后,推送到调用链处理器。该方案虽然侵入了业务，但只需要开发AOP切面拦截类，耦合不严重
- JavaAgent字节码增强：JavaAgent可以构建一个独立于应用程序的代理程序，检测JVM上的程序，甚至能替换、修改某些类的定义，实现定制化
- 代理推送：使用日志文件通过应用程序打印相关调用日志，推送到日志中信，再从日志中心提取调用日志，组成调用链。常用Kafka消息队列、UDP推送（性能高），但是都需要使用异步方式发送数据，因为一旦收集器出现问题，会影响业务。  

### 6.4 处理器

收集端的处理器需要对收集的信息进行处理，通常我们会使用 Java 开发一个处理器， 对从UDP 或者 Kafka 消息队列消费得到的日志进行聚合，然后存入调用链的大数据存储系统中 。  

一般在生产实践过程中，我们在处理器中除了要对调用链进行聚合，还需要从调用链中发现调用的问题 ， 例如：抛异常、超时、服务响应时间过长等 。 这时我们需要使用类似 Storm、Spark 等流式计算系统对恢复的调用链进行分析，然后发送给报警和监控系统 。  

如图所示：  

![](../images/micro/12.png)   

一条调用链包含一个用户请求在服务化架构中的多次调用信息 ，每个调用信息分成 4 个阶段，每个阶段都有不同类型的信息进行存储。一般来说一个调用信息包含 4 个类型的具体信息，一个中型公司线上服务的请求每天可以达到上千万或者上亿级别，因此为了存储这么大的调用链数据，我们需要使用大数据存储技术。由于调用链本身是一个树形结构，而且没有固定的模式，数据量和消息数量也不固定，因此， HBase 是比较合适的存储系统，另外，基于 HBase 的TSDB 也适合存储基于时序的数据。 