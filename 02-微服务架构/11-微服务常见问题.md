## 一 缓存穿透

### 1.1 缓存穿透概述

数据的查询需要先经过缓存，当缓存命中后，直接返回缓存中的数据。在缓存未命中的情况下，去数据库查询数据，并写入缓存。缓存的目的是为了尽可能将请求在缓存层处理，避免大量的请求进入存储层，达到保护存储层的效果。  

缓存穿透：频繁查询根本不存在的数据，导致缓存层和存储层都不会命中，因为这部分数据查询频繁，缓存不能有效命中，导致存储层负载加大。  

通常可以在应用程序中分别统计总调用数、缓存层命中数和存储层命中数。如果发现大量存储层空命中，就有可能出现缓存穿透问题。  

造成缓存穿透的原因：
- 应用程序自身设计问题，如缓存、数据库错误
- 被恶意攻击，如爬虫

### 1.2 解决办法一：缓存空对象

在缓存层未命中时，将该空对象存储到缓存层，那么之后的访问将会在缓存层命中，获得空对象。  

该方式会有两个问题：
- 造成存储空间增长、浪费
- 缓存层与持久层可能出现数据不一致现象。即在缓存有效期内，持久层的数据如果更新了，需要使用消息队列、定时刷新工具等刷新缓存层对象。

### 1.3 解决办法二：布隆过滤器拦截

布隆过滤器用于检测一个元素是否在一个集合中，由一个很长的二进制向量和一系列随机映射函数组成。  

布隆过滤器的核心思想是：使用M个Hash函数，通过每个哈希函数对每个key生成一个整数值。在初始状态下，需要一个长度为N的比特数组，比特数组每一位都是0。当某个key加入布隆过滤器时，使用M个哈希函数计算出M个哈希值，并且根据K个哈希函数计算出M个哈希值，根据生成的M个哈希值查找比特数组中对应的比特位。只有当所有的哈希值对应的比特位都为1时，认为此时key在布隆过滤器中，否则认为此key不在布隆过滤器中。  

![](./../images/micro/20.svg)  

按照K1和K2的添加步骤，依次将所有存储层已经存在的key以及存储层新增的key都加入布隆过滤器中。  

当用户请求携带Kn经过布隆过滤器时:  

![](./../images/micro/21.svg)  

由于F2（Kn）对应的比特位位0，此时认为Kn不在布隆过滤器中，因此可以在布隆过滤器这一层将请求拦截，在一定程度上保护了存储层。  

可以在应用层面使用Google Guava框架实现布隆过滤器，也可以利用Redis的Bitmaps实现布隆过滤器。

## 二 缓存雪崩

缓存大量失效、穿透后会导致大量请求到达持久层，这就是缓存雪崩现象。  
常用的缓存雪崩处理方案：
- 保持缓存层的高可用：多实例、多机房部署缓存，如Redis
- 优化存储过期时间：为key设置合适的过期时间，避免大量key在同一时刻失效
- 使用互斥锁重建缓存
- 异步重建缓存

**互斥锁重建缓存**：  
在高并发场景中，为了避免大量请求同时到达存储层查询数据库造成重建缓存，可以使用互斥锁。  

如：根据key查询数据，当缓存层命中时，对key加锁，然后从存储层查询数据，将数据写入缓存层，最后释放锁，若其他线程获取锁失败，则让线程休眠一段时间后重试。在分布式redis中，可以使用SETNX方法。 

该方式利用代码实现了缓存重建，较为复杂，而且当前并发1000请求时，999个都在阻塞！  

**异步重建缓存**：  
该方案从线程池中获取线程来异步构建缓存，从而不会让所有的请求直接到达存储层。  

如：每个Redis key维护逻辑超时时间，当逻辑超时时间小于当前时间时，说明缓存失效，应当进行缓存更新，否则直接返回缓存的值


##  三 微服务可用性设计-容错设计

### 3.1 消除单点

提升可用性的最简单、有效的方法就是：消除单点、多借点部署！一般要求节点数为n+2，这里不是n+1的原因是：升级时，要升级一个节点，剩下2个节点正常提供服务时，还可以允许一个节点失效。  

### 3.2 特性开关

多人开发微服务项目时，M功能完成准备部署，但是N功能却未开发完毕，为了能够保证M服务的持续部署，需要确定一个特性开关，关闭N，  

简单的特性开关可以通过配置文件或者一个变量来实现。  

当实例较多时，一个一个配置较为麻烦，可以建立一个通用的特性开关服务，比如阿里的switch，每5秒轮询一次特性开关服务。   

### 3.3 服务分级

微服务架构中，服务数量越多，依赖关系就越复杂，一个普通的接口请求，在微服务服务端，可能需要调用很多服务才能完成请求。当服务数量较多时，应该书里出业务的核心流程，找到核心的服务是哪些，根据这些给服务分级。  

服务分级在实现上就是给服务打标签，表示服务的关键程度，一般分为四个级别：
- 1级服务：核心业务流程，如：支付、下单
- 2级服务：用户体验会受到影响，如：评论、物流
- 3级服务：用户体验轻微影响，如：推荐、积分
- 4级服务：管理类服务，用户不会直接访问，如：报表

### 3.4 服务降级

降级的目的是保障核心功能，利用当前有限资源，通过开关手段暂时关闭非核心服务。常用操作有：
- 关闭某个功能
- 请求短路，或者直接返回缓存结果
- 简化流程，放弃某个操作
- 延迟执行

注意：降级的前提是对服务进行过分级。

### 3.5 超时重试

生产者调用消费者，清奇的状态有成功、失败、超时三种。超时后，频繁发起重试，可能会加重消费者负担，所以需要考虑如下参数：
- 超时时间
- 重试总次数
- 重试间隔时间
- 重试间隔时间衰减度

案例一：监控系统M监控着服务S，M每隔2秒发送心跳到S，超时时间为1秒，重试三次后如果还是失败，则重启S，该方式容易引起级联故障，重启也治标不治本。设置重启参数时需要参考服务S依赖服务的执行时间、超时时间设置。  

案例二：某服务98%请求执行时间要在1秒以内，1%的执行时间要在10秒以上。为了降低容错，超时时间设置为10秒是不合理的，不能因为个别案例降低整体可用性。  

常见的重试模式：
- 简单重试模式：即try-catch-redo，在catch中重试，并适当增加休眠时间
- 策略重试模式：即try-catch-redo-retry，增加重试次数，重试间隔周期，以及重试间隔周期衰减的实际weakTime，从而增加重试有效性。
- 基于Guava-retrying重试：Guava-retrying是谷歌Guava库的重试插件。

### 3.6 隔离策略与熔断器

隔离是为了在系统故障时，限制传播范围。比如秒杀服务，需要大量资源，一般会将秒杀和其他业务隔离开。  

常见隔离策略：
- 线程池隔离：核心业务，可以独占一个线程池
- 进程隔离：在微服务中，可以把核心流程独立为一个服务，单独部署，进行进程级的隔离
- 集群隔离：大规模及群众，有可能管理的服务需要和终端用户的服务进行隔离，因为后台的一个操作可能会影响终端用户
- 用户隔离：如运营人员修改了价格，数据进入分布式消息中间件，其他商家修改价格的操作会被阻塞，引起排队。如果能够根据条数、用户进行隔离，可以提升用户体验
- 租户隔离：用户隔离的特殊形式，对隔离性要求更高，主要有三种：
  - 逻辑隔离：在数据库加字段尽心隔离。实现简单，节省资源，但是隔离不彻底
  - 物理隔离：部署独立的服务和数据库，划分独立带宽。隔离彻底，但是成本较高
  - 混合隔离：上述两种方案的组合

常见的隔离软件为：Hystrix。该组件提供两种隔离方案：
- 线程池隔离
- 信号量隔离

我们也常称呼 Hystrix 为熔断器，其隔离模式为：熔断器模式。当发生短路或者超负荷时，熔断器能够主动熔断电路，避免灾难发生。在分布式系统中，消费者发生大量超时时，服务提供者能够主动熔断，繁殖服务被进一步拖垮，当情况变好后，服务提供者又能重新提供服务。  

## 四 微服务可用性设计-流控设计

### 4.0 限流概念

> 限流：调节数据流的平均熟虑，通过限制速率保护系统，提升可用性。

### 4.1 限流算法

限流方式一：**计数器**  
- 原理：限制一秒钟能通过的请求数，比如限流QPS为100，则从第一个请求进入开始，在接下来一秒内，每来一个请求，计数器+1，累加数目到达100，则后续请求被拒绝。
- 弊端：在1秒钟内，前10毫秒处理了100个请求，那么后面的990毫秒就会拒绝所有请求，这种现象称为突刺现象

限流方式二：**漏桶算法 Leaky Bucket**
- 原理：一个固定容量的漏桶按照敞亮固定速率流出水滴，如果桶是空的，就不需要流出水滴。我们可以让任意速率的水，流入漏桶，如果流入的水滴超出桶的容量，流入的水滴就会溢出（被丢弃），而漏桶的容量是不变的。  
- 作用：解决计数器的弊端，即让突发流量整形，以便让网络提供稳定的流量

漏桶算法图解：  
![](../images/micro/18.svg)  

限流方式三：**令牌桶算法 Token Bucket**  
- 原理：常用的限流算法。令牌按固定的速率放入令牌桶，例如：token/秒。桶中最多存放b个令牌（token），当桶装满时，新添加的令牌被丢弃或拒绝。当请求到达时，将从桶中删除1个令牌。令牌桶中的令牌不仅可以被移除，还可以往里添加。为了保证接口的数据能随时通过，必须不停的往桶里添加令牌。所以添加令牌的速度决定了单位时间内通过的接口数量。  

![](../images/micro/19.svg)  

令牌桶与漏桶算法区别：
- 拒绝请求方式不同：
  - 漏桶算法流入速度任意，但是按照常量固定流出。当流入的请求数量积累到漏桶容量时，新请求被拒绝
  - 令牌桶算法是按照固定速率往桶中添加令牌的，请求是否被处理需要看桶中的令牌是否足够。令牌数为0，请求被拒绝
- 突发请求处理不同：
  - 漏桶算法限制常量流出速率，使突发流量速率平滑
  - 令牌桶算法允许突发请求，只要有令牌即可，允许了一定程度上的突发流量

### 4.2 限流设计

在多实例场景中如何进行限流设计？
- 请求入口处：比如通过Nginx进行限量，该效果最好
- 业务入口处：依赖于微服务框架，对每个服务节点进行仙灵，通过设置最大连接数，最大线程数等实现
- 公共服务处：如缓存服务等基础服务，宕机后果严重，可以对公共基础服务进行先练。

### 4.3 限流库

Guava是Google开发的Java类扩展，其限流工具类RateLimiter采用的是令牌桶算法。  

Nginx的限流：
- ngx_http_limit_conn_module模块：连接数控制，可以实现限制并发访问
- ngx_http_limit_req_module模块：限制请求处理频率，使用了漏桶算法，限制了每秒固定处理的请求数  
